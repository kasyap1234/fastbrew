package bundle

import (
	"fmt"
	"io"
	"sort"
	"strings"
	"time"
)

// Generator creates Brewfile content from dumped package information
type Generator struct {
	opts GeneratorOptions
}

// GeneratorOptions configures Brewfile generation
type GeneratorOptions struct {
	IncludeHeader    bool
	IncludeDate      bool
	GroupByType      bool
	AlphabeticalSort bool
	IncludeVersions  bool
	Descriptions     bool
}

// DefaultGeneratorOptions returns sensible defaults
func DefaultGeneratorOptions() GeneratorOptions {
	return GeneratorOptions{
		IncludeHeader:    true,
		IncludeDate:      true,
		GroupByType:      true,
		AlphabeticalSort: true,
		IncludeVersions:  false,
		Descriptions:     false,
	}
}

// NewGenerator creates a generator with the given options
func NewGenerator(opts GeneratorOptions) *Generator {
	return &Generator{opts: opts}
}

// Generate writes a Brewfile to the given writer
func (g *Generator) Generate(w io.Writer, result *DumpResult) error {
	if g.opts.IncludeHeader {
		if err := g.writeHeader(w); err != nil {
			return err
		}
	}

	if g.opts.GroupByType {
		return g.generateGrouped(w, result)
	}

	return g.generateFlat(w, result)
}

func (g *Generator) writeHeader(w io.Writer) error {
	header := "# Brewfile"
	if g.opts.IncludeDate {
		header += fmt.Sprintf(" generated on %s", time.Now().Format("2006-01-02"))
	}
	header += "\n# Generated by fastbrew bundle dump\n\n"
	_, err := w.Write([]byte(header))
	return err
}

func (g *Generator) generateGrouped(w io.Writer, result *DumpResult) error {
	if len(result.Taps) > 0 {
		if _, err := w.Write([]byte("# Taps\n")); err != nil {
			return err
		}
		if err := g.writeTaps(w, result.Taps); err != nil {
			return err
		}
		if _, err := w.Write([]byte("\n")); err != nil {
			return err
		}
	}

	if len(result.Brews) > 0 {
		if _, err := w.Write([]byte("# Formulae\n")); err != nil {
			return err
		}
		if err := g.writeBrews(w, result.Brews); err != nil {
			return err
		}
		if _, err := w.Write([]byte("\n")); err != nil {
			return err
		}
	}

	if len(result.Casks) > 0 {
		if _, err := w.Write([]byte("# Casks\n")); err != nil {
			return err
		}
		if err := g.writeCasks(w, result.Casks); err != nil {
			return err
		}
		if _, err := w.Write([]byte("\n")); err != nil {
			return err
		}
	}

	if len(result.Mas) > 0 {
		if _, err := w.Write([]byte("# Mac App Store\n")); err != nil {
			return err
		}
		if err := g.writeMas(w, result.Mas); err != nil {
			return err
		}
		if _, err := w.Write([]byte("\n")); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateFlat(w io.Writer, result *DumpResult) error {
	if err := g.writeTaps(w, result.Taps); err != nil {
		return err
	}
	if err := g.writeBrews(w, result.Brews); err != nil {
		return err
	}
	if err := g.writeCasks(w, result.Casks); err != nil {
		return err
	}
	if err := g.writeMas(w, result.Mas); err != nil {
		return err
	}
	return nil
}

func (g *Generator) writeTaps(w io.Writer, taps []TapInfo) error {
	if g.opts.AlphabeticalSort {
		sort.Slice(taps, func(i, j int) bool {
			return taps[i].Name < taps[j].Name
		})
	}

	for _, tap := range taps {
		line := fmt.Sprintf("tap \"%s\"\n", tap.Name)
		if _, err := w.Write([]byte(line)); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) writeBrews(w io.Writer, brews []BrewInfo) error {
	if g.opts.AlphabeticalSort {
		sort.Slice(brews, func(i, j int) bool {
			return brews[i].Name < brews[j].Name
		})
	}

	for _, brew := range brews {
		if g.opts.Descriptions && brew.Description != "" {
			comment := fmt.Sprintf("# %s\n", brew.Description)
			if _, err := w.Write([]byte(comment)); err != nil {
				return err
			}
		}

		line := fmt.Sprintf("brew \"%s\"", brew.Name)

		if g.opts.IncludeVersions && brew.Version != "" {
			line += fmt.Sprintf(", version: \"%s\"", brew.Version)
		}

		if len(brew.Args) > 0 {
			args := make([]string, len(brew.Args))
			for i, arg := range brew.Args {
				args[i] = fmt.Sprintf("\"%s\"", arg)
			}
			line += fmt.Sprintf(", args: [%s]", strings.Join(args, ", "))
		}

		line += "\n"
		if _, err := w.Write([]byte(line)); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) writeCasks(w io.Writer, casks []CaskInfo) error {
	if g.opts.AlphabeticalSort {
		sort.Slice(casks, func(i, j int) bool {
			return casks[i].Name < casks[j].Name
		})
	}

	for _, cask := range casks {
		if g.opts.Descriptions && cask.Description != "" {
			comment := fmt.Sprintf("# %s\n", cask.Description)
			if _, err := w.Write([]byte(comment)); err != nil {
				return err
			}
		}

		line := fmt.Sprintf("cask \"%s\"", cask.Name)

		if g.opts.IncludeVersions && cask.Version != "" {
			line += fmt.Sprintf(", version: \"%s\"", cask.Version)
		}

		line += "\n"
		if _, err := w.Write([]byte(line)); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) writeMas(w io.Writer, apps []MasInfo) error {
	if g.opts.AlphabeticalSort {
		sort.Slice(apps, func(i, j int) bool {
			return apps[i].Name < apps[j].Name
		})
	}

	for _, app := range apps {
		line := fmt.Sprintf("mas \"%s\", id: %s\n", app.Name, app.ID)
		if _, err := w.Write([]byte(line)); err != nil {
			return err
		}
	}
	return nil
}
